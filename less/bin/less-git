#!/bin/bash
# -*- indent-tabs-mode: t; tab-width: 4; -*-

exec 3<&0

GIT_ROOT=$(git rev-parse --show-toplevel)

INPUT=$(mktemp -u)
SELECTION=$(mktemp -u)
ENTITY=$(mktemp -u)
mkfifo "$INPUT" "$SELECTION" "$ENTITY"
trap "rm '$INPUT' '$SELECTION' '$ENTITY'" EXIT

cat <&3 > "$INPUT" &

awk -lfilefuncs -vOFS='\t' -vcols="$COLUMNS" -vgit_root="$GIT_ROOT" -f- "$INPUT" <<-"EOF" |
	match($1 $2, /^(\033\[[[:digit:]]{2}m)?commit([[:xdigit:]]{40})(\033\[m)?/, m) {
		$1 = m[1] m[2] m[3]
	}

	$1 ~ /^(\033\[[[:digit:]]{2}m)?[[:xdigit:]]{7,}(\033\[0?m)?$/ {
		if ($1 in seen)
			next

		seen[$1] = 1

		display_sha = $1
		sha = gensub(/\033\[[[:digit:]]*m/, "", "g", $1)
		sha_length = length(sha)

		if (!("git show --format='%at %s' --no-patch " sha | getline))
			next

		if (sprintf("python3 -c '%s;print(%s)'",
		            "from datetime import date",
		            sprintf("(date.today() - date.fromtimestamp(%s)).days", $1)) | getline days)
			days = days " days ago"
        else
			days = ""

		subject = $2

		for (n = 3; n <= NF; ++n)
			subject = subject " " $n

		print "commit", sha, sprintf("%s %-*s\033[36m%s\033[0m", display_sha, cols - sha_length - length(days) - 4, subject, days)
		next
	}

	{
		for (n = 1; n <= NF; ++n) {
			sub(/^[ab]\//, "", $n)
			gsub(/\033[[[:digit:]]*m/, "", $n)
			file = git_root "/" $n

			if (file in seen || stat(file, st) != 0 || st["type"] != "file")
				continue

			print "file", file, $n
			seen[file] = 1
		}
	}
EOF

fzf -0 --ansi --height=5 --multi --with-nth=3.. > "$SELECTION" &

awk -vFS='\t' -vOFS='\t' -f- "$SELECTION" <<-"EOF" > "$ENTITY" &
	$1 == "commit" {
		if (commit) {
			print "error", "Multiple commits selected"
            exit
		}
		else {
			commit = $2
			summary = $3
		}
	}

	$1 == "file" {
		files[nfiles++] = $2
        if (summary)
			summary = summary " " $3
		else
			summary = $3
	}

	END {
		if (commit && nfiles) {
			print "error", "Both commits and files selected"
			exit
		}
		else if (commit) {
			print "commit", commit, summary
		}
		else if (nfiles) {
            printf "files\t%s", summary

			for (filei = 0; filei < nfiles; ++filei)
				printf "\t%s", files[filei]

			printf "\n"
		}
	}
EOF

function handle-error {
	echo "Error: $1" >&2
	exit 1
}

function show-commit {
	git show --patch-with-stat "$1"
}

function show-files-at-commit {
	local REV=$1

	git ls-files |
		fzf --header="Files in $GIT_ROOT" --height=10 --multi |
		while read FILE
		do
			local TEMP=$(mktemp --suffix="@$REV@${FILE////\\}@")
			trap "rm '$TEMP'" EXIT
			git highlight "$REV" "$FILE" > "$TEMP"
			printf '%s\0' "$TEMP"
		done |
		xargs -0 --no-run-if-empty $PAGER
}

function diff-files-at-commit {
	local REV=$1
	local DESC=$2

	git show --format= --name-only "$REV" |
		fzf --header="$DESC" --height=10 --multi |
		xargs -n1 --no-run-if-empty printf '%s/%s\n' "$GIT_ROOT" |
		xargs --no-run-if-empty git diff "$REV^..$REV" --
}

function log-commit {
	git log --color=always --decorate --graph --oneline "$1" |
		fzf --ansi --height=100% --layout=reverse-list --no-clear |
		awk -vOFS=$'\t' 'match($0, /((\<[[:xdigit:]]{7,}\>).*)$/, m) { print m[2], m[1] }' |
		{
			IFS=$'\t' read REV DESC && handle-commit "$REV" "$DESC"
		}
}

function log-commit-files {
	git ls-files |
		fzf --header="Files in $GIT_ROOT" --height=10 --multi |
		xargs --no-run-if-empty git log --stat "$1" --
}

function handle-commit {
	fzf --header="$2" --height=7 --with-nth=2.. <<-EOF |
		show-commit Show commit
		show-files-at-commit Show files at commit
		diff-files-at-commit Diff files at commit
		log-commit Git log
		log-commit-files Git log files at commit
	EOF
	{
		read -d' ' ACTION && "$ACTION" "$@"
	}
}

function examine-files {
	$PAGER "$@"
}

function log-files {
	git log --stat "$@"
}

function handle-files {
	local FILES=${@:2}

	fzf --header="$1" --height=4 --with-nth=2.. <<-EOF |
		examine-files Examine $([[ ${#FILES[@]} -eq 1 ]] && echo file || echo files)
		log-files Git log
	EOF
	{
		read -d' ' ACTION && "$ACTION" "${FILES[@]}"
	}
}

IFS=$'\t' read -a ENTITY < "$ENTITY" && "handle-${ENTITY[0]}" "${ENTITY[@]:1}"
