#!/bin/bash
# -*- indent-tabs-mode: t; tab-width: 4; -*-

exec 3<&0

GIT_ROOT=$(git rev-parse --show-toplevel)

INPUT=$(mktemp -u)
SELECTION=$(mktemp -u)
mkfifo "$INPUT" "$SELECTION"
trap 'rm "$INPUT" "$SELECTION"' EXIT

cat <&3 > "$INPUT" &

awk -lfilefuncs -vOFS='\t' -vcols="$COLUMNS" -vgit_root="$GIT_ROOT" -f- "$INPUT" <<-"EOF" |
	match($1 $2, /^(\033\[[[:digit:]]{2}m)?commit([[:xdigit:]]{40})(\033\[m)?/, m) {
		$1 = m[1] m[2] m[3]
	}

	$1 ~ /^(\033\[[[:digit:]]{2}m)?[[:xdigit:]]{7,}(\033\[0?m)?$/ {
		if ($1 in seen)
			next

		seen[$1] = 1

		display_sha = $1
		sha = gensub(/\033\[[[:digit:]]*m/, "", "g", $1)
		sha_length = length(sha)

		if (!("git show --format='%at %s' --no-patch " sha | getline))
			next

		if (sprintf("python3 -c '%s;print(%s)'",
		            "from datetime import date",
		            sprintf("(date.today() - date.fromtimestamp(%s)).days", $1)) | getline days)
			days = days " days ago"
        else
			days = ""

		subject = $2

		for (n = 3; n <= NF; ++n)
			subject = subject " " $n

		print "commit", sha, sprintf("%s %-*s\033[36m%s\033[0m", display_sha, cols - sha_length - length(days) - 4, subject, days)
		next
	}

	{
		for (n = 1; n <= NF; ++n) {
			sub(/^[ab]\//, "", $n)
			gsub(/\033[[[:digit:]]*m/, "", $n)
			file = git_root "/" $n

			if (file in seen || stat(file, st) != 0 || st["type"] != "file")
				continue

			print "file", file, $n
			seen[file] = 1
		}
	}
EOF

fzf -0 --ansi --height=5 --multi --with-nth=3.. >"$SELECTION" &

awk -vFS='\t' -vOFS='\t' -f- "$SELECTION" <<-"EOF" |
	$1 == "commit" {
		if (commit) {
			print "error", "Multiple commits selected"
            exit
		}
		else {
			commit = $2
			summary = $3
		}
	}

	$1 == "file" {
		files[nfiles++] = $2
        if (summary)
			summary = summary " " $3
		else
			summary = $3
	}

	END {
		if (commit && nfiles) {
			print "error", "Both commits and files selected"
			exit
		}
		else if (commit) {
			print "commit", commit, summary
		}
		else if (nfiles) {
            printf "files\t%s", summary

			for (filei = 0; filei < nfiles; ++filei)
				printf "\t%s", files[filei]

			printf "\n"
		}
	}
EOF

while IFS=$'\t' read TYPE VALUE REST
do
	case $TYPE in
		error)
			echo error "$VALUE"
			exit
			;;

		commit)
			fzf --header="$REST" --height=7 --with-nth=2.. <<-EOF |
				show-commit Show commit
				show-files-at-commit Show files at commit
				diff-files-at-commit Diff files at commit
				log-commit Git log
				log-files Git log files at commit
			EOF
            while read ACTION _
			do
                case $ACTION in
					show-commit)
						echo show-commit "$VALUE"
						;;

					show-files-at-commit)
						git ls-files |
							fzf --header="Files in $GIT_ROOT" --height=10 --multi |
							xargs --no-run-if-empty echo show-files-at-commit "$VALUE"
						;;

					diff-files-at-commit)
						git show --format= --name-only "$VALUE" |
							fzf --header="$REST" --height=10 --multi |
							xargs -n1 --no-run-if-empty printf '%s/%s\n' "$GIT_ROOT" |
							xargs --no-run-if-empty echo diff-files-at-commit "$VALUE"
						;;

					log-commit)
						echo log-commit "$VALUE"
						;;

					log-files)
						git ls-files |
							fzf --header="Files in $GIT_ROOT" --height=10 --multi |
							xargs --no-run-if-empty echo log-files "$VALUE"
						;;
				esac
			done
			;;

		files)
			IFS=$'\t'
			FILES=($REST)
			fzf --header="$VALUE" --height=4 --with-nth=2.. <<-EOF |
				examine-files Examine $([[ ${#FILES[@]} -eq 1 ]] && echo file || echo files)
				log-files Git log
			EOF
			while IFS=" " read ACTION _
			do
				echo "$ACTION" "${FILES[@]}"
			done
			;;
	esac
done |

while read ACTION VALUE
do
    case $ACTION in
		error)
			echo "Error: $VALUE" >&2
			exit 1
			;;

		diff-files-at-commit)
			set $VALUE
			REV=$1
			shift
			echo "$@"
			git diff "$REV^..$REV" -- "$@"
			;;

		examine-files)
			$PAGER $VALUE
			;;

		log-commit)
			git log "$VALUE"
			;;

		log-files)
			git log --stat $VALUE
			;;

		show-commit)
			git show --patch-with-stat "$VALUE"
			;;

		show-files-at-commit)
			set $VALUE
			REV=$1
			shift

			for FILENAME in "$@"
			do
				FILE=$(mktemp --suffix="@$REV@${FILENAME////\\}@")
				FILES=("${FILES[@]}" "$FILE")
				trap "rm '$FILE'" EXIT
				git highlight "$REV" "$FILENAME" > "$FILE"
			done

			$PAGER "${FILES[@]}"
			;;
	esac
done
